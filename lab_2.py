#!/usr/bin/env python
# coding: utf-8

# In[2]:


import random

# функция принимает количество всех полей и генерирует эти поля
def generator(countOfFields):
    """
    Функция генерирует список полей, состоящих из данных об экспортируемых товарах, таких как наименование 
    товара, страна (куда экспортируется товар), объем поставляемой продукции, сумма в рублях.
    
    :param countOfFields: Размерность (количество полей).
    :type countOfFields: int
    
    :return: Возвращает список всех полей.
    :rtype: list
    """
    # наименование товара
    name = { # название товара - ключ, вариация цены за штуку - значение
            "Яблоки": (10, 20), 
            "Груши": (15, 30),
            "Картофель": (5, 15),
            "Ананасы": (30, 100),
            "Виноград": (2, 10),
            "Мандарины": (15, 25),
            "Клубника": (10, 15),
            "Бананы": (5, 25),
            "Черешня": (5, 15),
            "Дыни": (50, 100),
           }
    
    # страна (куда экспортируется товар)
    country = ["Россия", "Китай", "США", "Грузия", "Казахстан", 
               "Алжир", "Индия", "Швеция", "Франция", "Финляндия"]
    
    data = [] # список всех полей 
    field = [] # список одного поля
    for _ in range(countOfFields):
        for_name = random.randint(0, 9) # генерация числа от 0 до 9 для выбора случайного названия продукта
        for_country = random.randint(0, 9) # генерация числа от 0 до 9 для выбора случайной страны
        
        # заполнение поля
        field.append(list(name.keys())[for_name]) # добавление случайного названия продукта в поле
        field.append(country[for_country]) # добавление случайной страны в поле
        field.append(v := random.randint(1000, 10_000)) # добавление случайного объема в поле, v - объем поставляемой продукции
        field.append(v * random.randint(*name[list(name.keys())[for_name]])) # добавление цены, относительно объема
        
        data.append(field) # запись поля в список всех полей
        field = [] # очищение списка для одного поля
        
    return data

cOF = [100, 200, 500, 700, 1000, 2000, 3500, 5000, 6000, 7000, 10_000, 20_000, 50_000, 70_000, 100_000] # список количества наборов данных

# запись в файл
import json

for c in cOF:
    with open(f'..\data\db_{c}.txt', 'w') as outfile: # открытие файлов на запись
        json.dump(generator(countOfFields = c), outfile) # запись списка всех полей в файл

class exportedGoods():
    """
    Класс, содержащий в себе данные об экспортируемых товарах.

    :param name: Наименование товара
    :type name: str
    
    :param country: Страна (куда экспортируется товар)
    :type country: str
    
    :param volume: Объем поставляемой продукции
    :type volume: int
    
    :param price: Сумма в рублях
    :type price: int

    """
    # конструктор класса
    def __init__(self, name, country, volume, price):
        """
        Конструктор класса.
        """
        self.name = name
        self.country = country
        self.volume = volume
        self.price = price
        
    # строковое представление объекта
    def __str__(self): # для читаемости
        """
        Перегрузка метода __str__.
        Строковое представление объекта.
        
        :return: Возвращает строковое представление объекта.
        :rtype: str
        """
        return self.name + ' ' + self.country + ' ' + str(self.volume) + ' ' + str(self.price)
        
    def __repr__(self): # однозначное представление объекта в виде строки
        return self.__str__()
    
    
    # перегрузка >
    def __gt__(self, other):
        """
        Перегрузка оператора >

        :param other: Объект класса :class:`exportedGoods`, с которым проводится сравнение 
        :type other: :class:`exportedGoods`

        :return: True, если данный объект больше объекта other, иначе False
        :rtype: bool
        """
        return self.name > other.name
    
    # перегрузка <
    def __lt__(self, other): 
        """
        Перегрузка оператора <

        :param other: Объект класса :class:`exportedGoods`, с которым проводится сравнение 
        :type other: :class:`exportedGoods`

        :return: True, если данный объект меньше объекта other, иначе False
        :rtype: bool
        """
        return self.name < other.name
    
    # перегрузка >=
    def __ge__(self, other):
        """
        Перегрузка оператора >=

        :param other: Объект класса :class:`exportedGoods`, с которым проводится сравнение 
        :type other: :class:`exportedGoods`

        :return: True, если данный объект больше или равен объекта other, иначе False
        :rtype: bool
        """
        return not (self < other)
        
    # перегрузка <=
    def __le__(self, other): 
        """
        Перегрузка оператора <=

        :param other: Объект класса :class:`exportedGoods`, с которым проводится сравнение 
        :type other: :class:`exportedGoods`

        :return: True, если данный объект меньше или равен объекта other, иначе False
        :rtype: bool
        """
        return not (self > other)


# сортировка слиянием
# выполнение сортировки
def mergeSort(lst):
    """
    Сортировка слиянием. В данной функции проиходит рекурсивное распадания массивов
    на две части. Далее два образовавшихся массива передаются в функицю mergeTwoList,
    в которой происходит объединение переданных массивов.

    :param lst: Массив, который нужно отсортировать
    :type lst: list

    :return: Объединенный массив
    :rtype: list
    """
    if len(lst) == 1:  # если список состоит из одного элемента, то мы возвращаем его
        return lst

    # рекурсивное распадание списков
    left_part = mergeSort(lst[:len(lst) // 2])  # находим левую часть от начала до середины не включительно
    right_part = mergeSort(lst[len(lst) // 2:])  # находим правую часть от середины и до конца списка

    # объединение двух списков
    return mergeTwoList(left_part, right_part)


# объединение двух списков
def mergeTwoList(lst1, lst2):
    """
    В данной функции происходит объединение двух массивов. При чем элемент первого массива
    сравнивается с элементом второго массива и меньший элемент добавляется в объединенный массив.
    Если один из массивов достигает конца после цикла, а другой нет, то в объединенный массив
    добавляются оставшиеся элементы не достигшего конца массива.

    :param lst1: Массив, который нужно объединить со вторым массивом
    :type lst1: list
    :param lst2: Массив, который нужно объединить с первым массивом
    :type lst2: list

    :return: Объединенный массив
    :rtype: list
    """
    lst = []
    i = 0  # указывает на первый элемент списка lst1
    j = 0  # указывает на первый элемент списка lst2

    while i < len(lst1) and j < len(lst2):  # пока указатели элементов списка не превышают длины этих списков
        # цикл будет выполнятся
        if lst1[i] < lst2[j]:  # если i-й элемент списка lst1 меньше j-го элемента списка lst2,
            # то i-й элемент списка lst1 добавляется в объединенный список
            # и мы продвигаемся по списку дальше
            lst.append(lst1[i])
            i += 1
        else:  # если j-й элемент списка lst2 меньше или равен i-му элементу списка lst2,
            # то j-й элемент списка lst2 добавляется в объединенный список
            # и мы продвигаемся по списку дальше
            lst.append(lst2[j])
            j += 1

    # после цикла один список может достигнуть конца, а второй нет
    if i < len(lst1):
        lst += lst1[i:]
    if j < len(lst2):
        lst += lst2[j:]

    # возвращаем объединенный список
    return lst

# прямой поиск
def directSearch(key, lst):
    """
    В данной функции реализован прямой поиск. Проходимся по массиву и поэлементно делаем
    сравнение с ключем. Если элемент с ключем совпадает, то мы добавляем его в новый массив. Если
    элемент не нашелся, то возвращаем -1, иначе получившийся массив.

    :param key: Ключ, по которому осуществляется поиск
    :type key: str
    :param lst: Исходный массив, в котором осуществляется поиск
    :type lst: list

    :return: Массив найденных элементов
    :rtype: list
    """
    search_lst = []
    for el in lst:  # проходимся по массиву и поэлементно делаем сравнение с ключем,
        # если элемент с ключем совпадает, то мы добавляем его в новый массив
        if key == el.name:
            search_lst.append(el)

    if len(search_lst) != 0:  # если элемент не нашелся, то возвращаем -1, иначе получившийся массив
        return search_lst
    else:
        return -1


from math import ceil, floor


# бинарный поиск
def binarySearch(key, lst):
    """
    В данной функции реализован бинарный поиск. Сравниваем центральный элемент с ключем.
    Если центральный элемент массива больше ключа, то отбрасываем левую часть массива.
    Если центральный элемент массива меньше ключа, то отбрасываем правую часть массива.
    И продолжаем этот алгоритм, пока не найдем нужный элемент, либо поймем, что данного
    элемента в массиве нет. Если элемент был найден, то переходим к следующему этапу поиска,
    и после его завершения возращаем массив, с найденными элементами. Если данного элемента
    в массиве нет, то возвращаем -1.

    :param key: Ключ, по которому осуществляется поиск
    :type key: str
    :param lst: Исходный массив, в котором осуществляется поиск
    :type lst: list

    :return: Массив найденных элементов
    :rtype: list
    """
    left = 0  # указатель на левую границу
    right = len(lst) - 1  # указатель на правую границу

    while left <= right:  # если правая граница стала >= левой, тогда это эквивалентно тому,
        # что элемент не был найден
        mid = (left + right) // 2  # указатель на центральный элемент массива
        if lst[mid].name < key:  # если элемент < ключа, тогда мы сдвигаем левую границу вправо на mid + 1
            left = mid + 1
        elif lst[mid].name > key:  # если элемент > ключа, тогда мы сдвигаем правую границу влево на mid - 1
            right = mid - 1
        else:  # если элемент равен ключу, тогда мы переходим к следующему этапу поиска
            # возвращаем склеенные списки, исключая в левом последний элемент
            return binSecondPhase(lst, left, mid, key)[:-1] + binSecondPhase(lst, mid, right, key)
    return -1


def binSecondPhase(lst, start, end, key):
    """
    Данная функция является продолжением бинарного поиска. Сравниваются элементы массива,
    на которые указывают start и end с ключем, тогда возвращается список элементов, иначе
    будет выполняться следующий алгаритм: если элемент, на который указывает фиксированная
    левая граница совпадает с ключем и центральный элемент не совпадает с ключем, тогда
    сдвигаем правую границу на указатель на центральный элемент с округлением вниз. Если
    данное условие не выполняется, тогда сравниваются элемент, на который указывает
    фиксированная левая граница и центральный элемент с ключем, и если они совпадают,
    то правая граница уменьшается на 1. Если данное условие не выполняется, тогда проверяется
    если элемент, на который указывает фиксированная правая граница совпадает с ключем
    и центральный элемент не совпадает с ключем, то сдвигается левая граница на указатель
    на центральный элемент с округлением вверх. Если данное условие тоже не выаолняется, тогда
    сравниваются элемент, на который указывает фиксированная правая граница и центральный элемент
    с ключем. Если они совпадают, то левая граница увеличивается на 1. Возвращается список
    найденных элементов.

    :param lst: Исходный массив, в котором осуществляется поиск
    :type lst: list
    :param start: левая граница массива
    :type start: int
    :param end: правая граница массива
    :type end: int
    :param key: Ключ, по которому осуществляется поиск
    :type key: str

    :return: Массив найденных элементов
    :rtype: list
    """
    while lst[start].name != key or lst[end].name != key:  # если элементы массива, на которые указывают start и end
        # совпали с key, тогда возвращаем найденный список элементов
        if lst[start].name == key and lst[
            floor((start + end) / 2)].name != key:  # если элемент, на который указывает фиксированная левая граница
            # совпадает с ключем и центральный элемент не совпадает с ключем
            # тогда сдвигаем правую границу на указатель
            # на центральный элемент с округлением вниз
            end = floor((start + end) / 2)
        elif lst[start].name == key and lst[
            floor((start + end) / 2)].name == key:  # если элемент, на который указывает фиксированная левая граница
            # и центральный элемент совпадают с ключем, то правую границу уменьшаем на 1
            end -= 1
        elif lst[ceil((start + end) / 2)].name != key and lst[
            end].name == key:  # если элемент, на который указывает фиксированная правая граница
            # совпадает с ключем и центральный элемент не совпадает с ключем
            # тогда сдвигаем левую границу на указатель
            # на центральный элемент с округлением вверх
            start = ceil((start + end) / 2)
        elif lst[ceil((start + end) / 2)].name == key and lst[
            end].name == key:  # если элемент, на который указывает фиксированная правая граница
            # и центральный элемент совпадают с ключем, то левую границу увеличиваем на 1
            start += 1

    return [lst[i] for i in range(start, end)]


# In[11]:





from datetime import datetime
from multidict import MultiDict # ассоциативный массив (в соответствие ключу ставится элемент)

time_lst_direct = [] # список времени выполнения прямого поиска
time_lst_bin = [] # список времени выполнения бинарного поиска
time_lst_bin_and_sort = [] # список времени выполнения бинарного поиска и сортировки
time_lst_md = [] # список времени выполнения поиска по ассоциативному массиву

for c in cOF:
    # чтение из файла
    with open(f'..\data\db_{c}.txt') as json_file: # открытие файла для чтения
        data = json.load(json_file) # загрузка данных из файла
    
    key = data[random.randint(0, len(data) - 1)][0] # ключ для поиска
        
    # добавление элементов, взятых из файла, в список (как объекты класса)
    lst = []
    for d in data:
        lst.append(exportedGoods(*d))
        
    # создаём и заполняем MultiDict
    multi_dict = MultiDict()
    for i in lst:
        multi_dict.add(i.name, i)

    # создание копии для сортировки
    lst1 = lst.copy() 

    # сортировки слиянием
    # запоминаем настоящее время до начала сортировки и бинарного поиска 
    # и настоящее время после окончания сортировки и бинарного поиска
    t_before = datetime.now()
    lst1 = mergeSort(lst1)
    binarySearch(key, lst1)
    t_after = datetime.now()

    # добавляем разность времени после окончания работы сортировки и бинарного поиска
    # и до начала работы сортировки и бинарного поиска
    # преобразовываем разность в строку и забираем секунды и микросекунды, как вещественное число  
    time_lst_bin_and_sort.append(float(str(t_after - t_before).split(":")[-1]))
    
    
    # запоминаем настоящее время до начала прямого поиска 
    # и настоящее время после окончания прямого поиска
    t_before = datetime.now()
    result_direct = directSearch(key, lst1)
    t_after = datetime.now()

    # добавляем разность времени после окончания работы прямого поиска
    # и до начала работы прямого поиска
    # преобразовываем разность в строку и забираем секунды и микросекунды, как вещественное число
    time_lst_direct.append(float(str(t_after - t_before).split(":")[-1]))
    
    
    # запоминаем настоящее время до начала бинарного поиска 
    # и настоящее время после окончания бинарного поиска
    t_before = datetime.now()
    result_bin = binarySearch(key, lst1)
    t_after = datetime.now()
    
    # добавляем разность времени после окончания работы бинарного поиска
    # и до начала работы бинарного поиска
    # преобразовываем разность в строку и забираем секунды и микросекунды, как вещественное число
    time_lst_bin.append(float(str(t_after - t_before).split(":")[-1]))
    
    
    # запоминаем настоящее время до начала поиска по ассациативному массиву
    # и настоящее время после окончания поиска по ассациативному массиву
    t_before = datetime.now()
    result_md = multi_dict.getall(key)
    t_after = datetime.now()
    
    # добавляем разность времени после окончания работы поиска по ассациативному массиву
    # и до начала работы поиска по ассациативному массиву
    # преобразовываем разность в строку и забираем секунды и микросекунды, как вещественное число
    time_lst_md.append(float(str(t_after - t_before).split(":")[-1]))
    
    
print(f"time_lst_direct = {time_lst_direct}\n")
print(f"time_lst_bin = {time_lst_bin}\n")
print(f"time_lst_bin_and_sort = {time_lst_bin_and_sort}\n")
print(f"time_lst_md = {time_lst_md}\n")


# In[10]:


print("result_direct = ", result_direct, "\n")
print("result_bin = ", result_bin, "\n")
print("result_md = ", result_md, "\n")

# построение графиков
import numpy as np
import matplotlib.pyplot as plt

time_lst_np = np.array(time_lst_direct)

plt.plot(cOF, time_lst_np, label="линейный поиск")
plt.legend()
plt.show()

# In[12]:


time_lst_np = np.array(time_lst_bin)

plt.plot(cOF, time_lst_bin, label="бинарный поиск")
plt.legend()
plt.show()

# In[13]:


time_lst_np = np.array(time_lst_bin_and_sort)

plt.plot(cOF, time_lst_bin_and_sort, label="бинарный поиск и сортировка")
plt.legend()
plt.show()

# In[14]:


time_lst_np = np.array(time_lst_md)

plt.plot(cOF, time_lst_md, label="multidict")
plt.legend()
plt.show()